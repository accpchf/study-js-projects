<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>数组排序方法</title>
</head>
<script type="text/javascript">
var array=[4,2,1,7,3];
console.log(array);
console.log("用sort()方法排序:");
array.sort();
console.log(array);
console.log("用reverse()方法反转:");
array.reverse();
console.log(array);

console.log("-----再排序");
var array2=[0,15,10,1,7,3];
console.log(array2);
array2.sort();
console.log(array2);//不是按数字排序，而是把数组项转换为字符串排序，利用字符串的localeCompare()比较，该方法返回1,-1,0

function compare(v1,v2){
	if(v1<v2){
		return -1;
	}else if(v1>v2){
		return 1;
	}else{
		return 0;
	}
}
console.log("sort()方法传人回调函数，也就是先定义好一个比较函数，然后在把函数名称传人就可以了，这是js的一个特性");
array2.sort(compare);//如果不传人回调函数，sort()方法内部默认调用localeCompare()
console.log(array2);


var compare2=function(v1,v2){
	return v1-v2;
}
var array3=[0,15,10,1,7,3];
console.log(array3);
console.log("----用一个简单函数来实现排序");
array3.sort(compare2);//定义好形参v1,v2，但是不需要传入v1，v2对应的实参
console.log(array3);

console.log("----模拟实现数组sort方法的源码，来理解为什么可以定义好形参v1,v2，但是不需要传入v1，v2对应的实参");
//数组的排序源码，大致是这样。
//先不要关心prototype是做什么，
Array.prototype.sort=function(compare_function){
	var array=this;//当前数组对象
	for(var i=0;i<array.length;i++){
		for(j=i;j<array.length;j++){//排序
			//注意比较方法调用，是不是可以简化为compare_function(v1,v2) ? 这就是js的妙处，把"回调函数"传人，不规定好函数的具体实现，只需要函数能返回就行
			//这里array[j],array[j+1]就是实参，回调函数的实参是在“内部”实现的
				if(compare_function(array[j],array[j+1])>0){ 
			//	if(compare_function(array[j],array[j+1])<0){ //如果不相信这个是数组的排序源码，那么我们改变一下这里的比较规则
				var temp=array[j];
				array[j]=array[j+1];
				array[j+1]=temp;
			}
		}
	}
	return array;
}


var array3=[0,15,10,1,7,3];
console.log(array3);
array3.sort(compare2);//不需要传v1,v2参数
console.log(array3);

</script>
</html>