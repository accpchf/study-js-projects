<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>用prototype来修改原生对象</title>
</head>
<script type="text/javascript">
	//给原生对象Number添加add方法，加法
	Number.prototype.add = function(x) {
		return this + x;
	};
	//添加减法
	Number.prototype.subtract = function (x) {
		  return this - x;
	};
	
	//将一个数值自动扩展为一个数组。
	Number.prototype.iterate = function () {
	  var result = [];
	  for (var i = 0; i <= this; i++) {
	    result.push(i);
	  }
	  return result;
	};
	
	console.log("(8).add(2) ="+( (8).add(2) ));//不可以 8.add(2), 8.会被解析为一个浮点数，所以用 (8).add(2)
	console.log("8['add'](2) ="+( 8['add'](2) ));//用方括号,也可以调用方法名
	console.log("8..add(2) ="+( 8..add(2) ));//8.是浮点数，8..add()开始调用方法
	console.log("(8).add(2).subtract(4) ="+( (8).add(2).subtract(4) ) );
	
	console.log("(10).iterate():");
	var array=(10).iterate();
	console.log(array);
	
	console.log("----模拟实现数组sort方法的源码");
	//定义一个比较方法
	var compare=function(v1,v2){
		return v1-v2;
	}
	//数组的排序源码，大致是这样。
	//先不要关心prototype是做什么，
	Array.prototype.sort=function(compare_function){
		var array=this;//当前数组对象
		for(var i=0;i<array.length;i++){
			for(j=i;j<array.length;j++){//排序
				//注意比较方法调用，是不是可以简化为compare_function(v1,v2) ? 这就是js的妙处，把"回调函数"传人，不规定好函数的具体实现，只需要函数能返回就行
				//这里array[j],array[j+1]就是实参，回调函数的实参是在“内部”实现的
					if(compare_function(array[j],array[j+1])>0){ 
				//	if(compare_function(array[j],array[j+1])<0){ //如果不相信这个是数组的排序源码，那么我们改变一下这里的比较规则
					var temp=array[j];
					array[j]=array[j+1];
					array[j+1]=temp;
				}
			}
		}
		return array;
	}

var array=[0,15,10,1,7,3];
console.log(array);
array.sort(compare);
console.log(array);
</script>
</html>